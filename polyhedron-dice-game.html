<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Polyhedral Dice Game</title>
    <style>
        /* CSS goes here */
        body {
            font-family: 'Arial', sans-serif;
            background-color: #2c3e50;
            color: #ecf0f1;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-start;
            min-height: 100vh;
            margin: 0;
            padding: 10px;
            box-sizing: border-box;
            overflow-x: hidden;
        }

        /* UPDATED: Game Header (now more like a menu bar) */
        .game-header {
            background-color: #34495e;
            border-radius: 10px;
            padding: 8px 15px; /* Reduced padding for compact bar */
            box-shadow: 0 0 15px rgba(0, 0, 0, 0.4);
            text-align: center;
            width: 100%;
            max-width: 900px;
            margin-bottom: 15px;
            box-sizing: border-box;
            display: flex; /* Use flexbox for internal layout */
            flex-direction: column; /* Stack h1 above the new content row */
            align-items: center;
            position: relative; /* For dropdown positioning */
        }

        .game-header h1 {
            color: #ecf0f1;
            margin: 0;
            font-size: 1.8em; /* Slightly smaller for compactness */
            margin-bottom: 5px; /* Space between title and menu */
        }

        /* Menu Bar Styling */
        .menu-bar {
            display: flex;
            gap: 15px; /* Spacing between menu items */
            flex-wrap: wrap; /* Allow items to wrap on smaller screens */
            justify-content: center; /* Center items in the bar */
        }

        .menu-item {
            position: relative; /* For dropdown positioning */
        }

        .menu-item button {
            background-color: #3498db;
            color: white;
            border: none;
            padding: 8px 15px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 0.9em;
            transition: background-color 0.2s ease;
        }

        .menu-item button:hover {
            background-color: #2980b9;
        }

        /* Dropdown Content */
        .dropdown-content {
            display: none;
            position: absolute;
            background-color: #34495e;
            min-width: 160px;
            box-shadow: 0px 8px 16px 0px rgba(0,0,0,0.6);
            z-index: 1;
            border-radius: 5px;
            top: 100%; /* Position below the button */
            left: 0; /* Align left with the button */
            padding: 10px;
        }

        .dropdown-content label {
            display: block;
            margin-bottom: 8px;
            color: #ecf0f1;
            white-space: nowrap; /* Prevent wrapping for options */
        }

        .dropdown-content input[type="checkbox"],
        .dropdown-content input[type="radio"] {
            margin-right: 5px;
        }

        .dropdown-content input[type="range"] {
            width: 100%;
            margin-top: 5px;
        }

        /* Show dropdown on hover (or focus/click for accessibility) */
        .menu-item:hover .dropdown-content,
        .menu-item button:focus + .dropdown-content { /* Basic focus for keyboard nav */
            display: block;
        }

        /* Container for game elements */
        .game-container {
            display: flex;
            flex-wrap: wrap; /* Allow wrapping for responsiveness */
            gap: 20px;
            width: 100%;
            max-width: 900px;
            justify-content: center;
        }

        .player-area, .game-log {
            background-color: #34495e;
            border-radius: 10px;
            box-shadow: 0 0 15px rgba(0, 0, 0, 0.4);
            padding: 20px;
            box-sizing: border-box;
        }

        .player-area {
            flex: 1; /* Allows player areas to grow and shrink */
            min-width: 300px; /* Minimum width for player areas */
            max-width: 450px;
        }

        .game-log {
            flex: 1;
            min-width: 300px;
            max-width: 450px;
            max-height: 500px; /* Limit height for scrolling */
            overflow-y: auto;
            display: flex;
            flex-direction: column; /* Stack log entries */
        }

        /* Responsive layout for game log position */
        .game-container.log-side {
            flex-direction: row; /* Default: side-by-side */
        }

        .game-container.log-bottom {
            flex-direction: column; /* Stack vertically */
            align-items: center; /* Center items when stacked */
        }

        .game-container.log-bottom .player-area,
        .game-container.log-bottom .game-log {
            width: 100%;
            max-width: 900px; /* Expand to full container width */
        }

        h2 {
            color: #e67e22;
            text-align: center;
            margin-top: 0;
            margin-bottom: 15px;
        }

        .player-info {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 1px solid #546a7e;
        }

        .player-info p {
            margin: 0;
            font-size: 1.1em;
        }

        .player-info .score {
            font-weight: bold;
            color: #27ae60;
        }

        .dice-container {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(70px, 1fr)); /* Responsive grid */
            gap: 10px;
            margin-bottom: 15px;
        }

        .die {
            background-color: #f39c12;
            color: #34495e;
            width: 70px;
            height: 70px;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            border-radius: 8px;
            font-size: 1.8em;
            font-weight: bold;
            cursor: pointer;
            transition: transform 0.1s ease, background-color 0.2s ease;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
            user-select: none; /* Prevent text selection */
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            border: 2px solid transparent; /* For selected state */
        }

        .die:active {
            transform: translateY(2px);
        }

        .die.locked {
            background-color: #95a5a6; /* Grey for locked dice */
            cursor: not-allowed;
            color: #7f8c8d;
        }

        .die.selected {
            border: 2px solid #3498db; /* Blue border for selected die */
            box-shadow: 0 0 10px #3498db;
        }

        .die-type {
            font-size: 0.5em;
            font-weight: normal;
            margin-top: 5px;
            color: rgba(52, 73, 94, 0.8);
        }

        .actions-container {
            display: flex;
            gap: 10px;
            justify-content: center;
            margin-bottom: 20px;
            flex-wrap: wrap; /* Allow buttons to wrap */
        }

        .actions-container button {
            background-color: #1abc9c;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 1em;
            transition: background-color 0.2s ease;
        }

        .actions-container button:hover:not(:disabled) {
            background-color: #16a085;
        }

        .actions-container button:disabled {
            background-color: #7f8c8d;
            cursor: not-allowed;
        }

        .message {
            background-color: #2980b9;
            color: white;
            padding: 10px;
            border-radius: 5px;
            text-align: center;
            margin-bottom: 15px;
            min-height: 40px; /* Ensure consistent height */
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .game-log p {
            background-color: #2c3e50;
            padding: 8px;
            border-radius: 5px;
            margin-bottom: 5px;
            font-size: 0.9em;
            line-height: 1.4;
            color: #bdc3c7;
        }

        .game-log p:last-child {
            margin-bottom: 0;
        }

        .log-entry-highlight {
            font-weight: bold;
            color: #f1c40f; /* Yellow for highlights */
        }

        /* Mind Attack specific styling */
        .mind-attack-section {
            background-color: #2c3e50;
            padding: 15px;
            border-radius: 8px;
            margin-top: 20px;
            border: 1px solid #e74c3c; /* Red border for emphasis */
            text-align: center;
        }

        .mind-attack-display {
            background-color: #34495e;
            border: 1px solid #e74c3c;
            padding: 10px;
            border-radius: 5px;
            min-height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.2em;
            color: #ecf0f1;
            margin-top: 10px;
            margin-bottom: 15px;
            white-space: pre-wrap; /* Preserve spaces and allow wrapping */
            word-wrap: break-word; /* Break long words */
        }

        .mind-attack-display span {
            font-family: 'Courier New', monospace; /* Monospaced font for formula */
        }

        .mind-attack-controls button {
            background-color: #e74c3c;
            margin: 5px;
        }

        .mind-attack-controls button:hover:not(:disabled) {
            background-color: #c0392b;
        }

        .mind-attack-controls button.clear {
            background-color: #f39c12; /* Orange for Clear */
        }

        .mind-attack-controls button.clear:hover:not(:disabled) {
            background-color: #e67e22;
        }

        /* Modal for target selection */
        .modal {
            display: none; /* Hidden by default */
            position: fixed; /* Stay in place */
            z-index: 1; /* Sit on top */
            left: 0;
            top: 0;
            width: 100%; /* Full width */
            height: 100%; /* Full height */
            overflow: auto; /* Enable scroll if needed */
            background-color: rgba(0,0,0,0.7); /* Black w/ opacity */
            display: flex; /* Use flexbox to center content */
            align-items: center;
            justify-content: center;
        }

        .modal-content {
            background-color: #34495e;
            margin: auto;
            padding: 30px;
            border: 1px solid #888;
            width: 80%; /* Could be responsive */
            max-width: 500px;
            border-radius: 10px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.5);
            text-align: center;
            color: #ecf0f1;
            position: relative;
        }

        .close-button {
            color: #aaa;
            position: absolute;
            top: 10px;
            right: 20px;
            font-size: 28px;
            font-weight: bold;
            cursor: pointer;
        }

        .close-button:hover,
        .close-button:focus {
            color: black;
            text-decoration: none;
            cursor: pointer;
        }

        .target-dice-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(60px, 1fr));
            gap: 10px;
            margin-top: 20px;
            max-height: 300px; /* Scrollable if many dice */
            overflow-y: auto;
            padding: 5px;
        }

        .target-die {
            background-color: #f39c12;
            color: #34495e;
            width: 60px;
            height: 60px;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            border-radius: 8px;
            font-size: 1.5em;
            font-weight: bold;
            cursor: pointer;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
            border: 2px solid transparent;
            transition: border 0.2s ease, transform 0.1s ease;
        }

        .target-die:hover {
            transform: translateY(-2px);
            border: 2px solid #2ecc71; /* Green on hover */
        }

        .target-die.selected-target {
            border: 3px solid #2ecc71; /* Green for selected target */
            box-shadow: 0 0 10px #2ecc71;
        }

        .target-die-player {
            font-size: 0.6em;
            color: rgba(52, 73, 94, 0.8);
            margin-top: 3px;
        }

        #confirmTargetBtn {
            background-color: #2ecc71;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 1em;
            margin-top: 20px;
        }

        #confirmTargetBtn:hover:not(:disabled) {
            background-color: #27ae60;
        }

        #confirmTargetBtn:disabled {
            background-color: #7f8c8d;
            cursor: not-allowed;
        }

    </style>
</head>
<body>
    <div class="game-header">
        <h1>Polyhedral Dice Game</h1>
        <div class="menu-bar">
            <div class="menu-item">
                <button id="newGameBtn">New Game</button>
            </div>
            <div class="menu-item">
                <button>Settings</button>
                <div class="dropdown-content">
                    <label>
                        <input type="checkbox" id="logPositionToggle" checked> Log on Side
                    </label>
                    </div>
            </div>
        </div>
    </div>

    <div class="message" id="message">Welcome! Roll the dice to start!</div>

    <div class="game-container" id="gameContainer">
        <div class="player-area" id="player1Area">
            <h2>Player 1</h2>
            <div class="player-info">
                <p>Score: <span id="player1Score">0</span></p>
                <p>Rolls Left: <span id="player1Rolls">3</span></p>
            </div>
            <div class="dice-container" id="player1Dice">
                </div>
            <div class="actions-container">
                <button id="rollDiceBtn1">Roll Dice</button>
                <button id="lockDiceBtn1">Lock Selected</button>
            </div>
            <div class="mind-attack-section">
                <h3>Mind Attack (Player 1)</h3>
                <p>Select a target die for Player 2, then build a formula to match its value.</p>
                <div class="mind-attack-display" id="mindAttackDisplay1">
                    <span></span>
                </div>
                <div class="mind-attack-controls">
                    <button class="mind-attack-target-btn" data-player="0">Select Target</button>
                    <button class="clear" data-player="0">Clear Formula</button>
                    </div>
            </div>
        </div>

        <div class="player-area" id="player2Area">
            <h2>Player 2</h2>
            <div class="player-info">
                <p>Score: <span id="player2Score">0</span></p>
                <p>Rolls Left: <span id="player2Rolls">3</span></p>
            </div>
            <div class="dice-container" id="player2Dice">
                </div>
            <div class="actions-container">
                <button id="rollDiceBtn2">Roll Dice</button>
                <button id="lockDiceBtn2">Lock Selected</button>
            </div>
            <div class="mind-attack-section">
                <h3>Mind Attack (Player 2)</h3>
                <p>Select a target die for Player 1, then build a formula to match its value.</p>
                <div class="mind-attack-display" id="mindAttackDisplay2">
                    <span></span>
                </div>
                <div class="mind-attack-controls">
                    <button class="mind-attack-target-btn" data-player="1">Select Target</button>
                    <button class="clear" data-player="1">Clear Formula</button>
                </div>
            </div>
        </div>

        <div class="game-log" id="gameLog">
            <h2>Game Log</h2>
            </div>
    </div>

    <div id="targetSelectionModal" class="modal">
        <div class="modal-content">
            <span class="close-button">&times;</span>
            <h2>Select Target Die</h2>
            <p>Choose a die to target for the Mind Attack:</p>
            <div class="target-dice-grid" id="targetDiceGrid">
                </div>
            <button id="confirmTargetBtn" disabled>Confirm Target</button>
        </div>
    </div>

    <script>
        const player1ScoreEl = document.getElementById('player1Score');
        const player2ScoreEl = document.getElementById('player2Score');
        const player1RollsEl = document.getElementById('player1Rolls');
        const player2RollsEl = document.getElementById('player2Rolls');
        const player1DiceContainer = document.getElementById('player1Dice');
        const player2DiceContainer = document.getElementById('player2Dice');
        const rollDiceBtn1 = document.getElementById('rollDiceBtn1');
        const lockDiceBtn1 = document.getElementById('lockDiceBtn1');
        const rollDiceBtn2 = document.getElementById('rollDiceBtn2');
        const lockDiceBtn2 = document.getElementById('lockDiceBtn2');
        const messageEl = document.getElementById('message');
        const gameLogEl = document.getElementById('gameLog');
        const mindAttackDisplay1 = document.getElementById('mindAttackDisplay1');
        const mindAttackDisplay2 = document.getElementById('mindAttackDisplay2');
        const mindAttackTargetBtns = document.querySelectorAll('.mind-attack-target-btn');
        const clearFormulaBtns = document.querySelectorAll('.mind-attack-section .clear');

        // Modal elements
        const targetSelectionModal = document.getElementById('targetSelectionModal');
        const closeButton = document.querySelector('#targetSelectionModal .close-button');
        const targetDiceGrid = document.getElementById('targetDiceGrid');
        const confirmTargetBtn = document.getElementById('confirmTargetBtn');

        // Layout preference toggle
        const logPositionToggle = document.getElementById('logPositionToggle');
        const gameContainer = document.getElementById('gameContainer');


        let players = [];
        let currentPlayerIndex = 0;
        const maxRolls = 3;
        const NUM_DICE_PER_PLAYER = 5;

        // Mind Attack variables
        let mindAttackMode = false;
        let selectedTargetDie = null; // { playerId: ..., dieId: ..., playerIndex: ... }
        let currentFormulaParts = []; // Stores numbers and operators as they are input
        let activeMindAttackPlayerIndex = -1; // Which player is currently performing a mind attack


        const diceTypes = {
            'd4': { min: 1, max: 4 },
            'd6': { min: 1, max: 6 },
            'd8': { min: 1, max: 8 },
            'd10': { min: 0, max: 9 }, // d10 can be 0-9 or 1-10, let's use 0-9
            'd12': { min: 1, max: 12 },
            'd20': { min: 1, max: 20 },
        };

        const NUMBERS = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9'];
        const OPERATORS = ['+', '-', '*', '/', '(', ')'];

        class Player {
            constructor(id, name) {
                this.id = id;
                this.name = name;
                this.score = 0;
                this.rollsLeft = maxRolls;
                this.dice = this.generateRandomDice(NUM_DICE_PER_PLAYER);
            }

            generateRandomDice(count) {
                const types = Object.keys(diceTypes);
                let newDice = [];
                for (let i = 0; i < count; i++) {
                    const randomType = types[Math.floor(Math.random() * types.length)];
                    newDice.push({
                        id: `die-${this.id}-${i}`,
                        type: randomType,
                        value: 0, // Initial value before roll
                        locked: false
                    });
                }
                return newDice;
            }

            rollDice() {
                if (this.rollsLeft <= 0) {
                    messageEl.textContent = `${this.name} has no rolls left!`;
                    return false;
                }

                let rollCount = 0;
                this.dice.forEach(die => {
                    if (!die.locked) {
                        const typeProps = diceTypes[die.type];
                        die.value = Math.floor(Math.random() * (typeProps.max - typeProps.min + 1)) + typeProps.min;
                        rollCount++;
                    }
                });
                this.rollsLeft--;
                messageEl.textContent = `${this.name} rolled ${rollCount} dice. Rolls left: ${this.rollsLeft}`;
                logGameEvent(`${this.name} rolled their dice.`, 'roll');
                return true;
            }

            lockDie(dieId) {
                const die = this.dice.find(d => d.id === dieId);
                if (die) {
                    die.locked = !die.locked;
                    messageEl.textContent = `${die.type} (${die.value}) is now ${die.locked ? 'locked' : 'unlocked'}.`;
                    logGameEvent(`${this.name} ${die.locked ? 'locked' : 'unlocked'} their ${die.type} die.`, 'lock');
                    return true;
                }
                return false;
            }

            calculateScore() {
                return this.dice.reduce((sum, die) => sum + die.value, 0);
            }
        }

        function initGame(isNewGame = false) {
            players = [new Player('player1', 'Player 1'), new Player('player2', 'Player 2')];
            currentPlayerIndex = 0;
            mindAttackMode = false;
            selectedTargetDie = null;
            currentFormulaParts = [];
            activeMindAttackPlayerIndex = -1;
            
            // Clear mind attack displays
            mindAttackDisplay1.querySelector('span').textContent = '';
            mindAttackDisplay2.querySelector('span').textContent = '';

            // If it's a completely new game, clear the log and reset message
            if (isNewGame) {
                gameLogEl.innerHTML = '<h2>Game Log</h2>';
                messageEl.textContent = "Welcome! Player 1's turn. Roll the dice!";
            } else {
                messageEl.textContent = `${players[currentPlayerIndex].name}'s turn. Roll your dice!`;
            }
            logGameEvent("Game initialized.", 'system');
            updateUI();
            togglePlayerControls(currentPlayerIndex);
        }

        function switchTurns() {
            currentPlayerIndex = 1 - currentPlayerIndex; // Toggles between 0 and 1
            const currentPlayer = players[currentPlayerIndex];
            messageEl.textContent = `${currentPlayer.name}'s turn. Rolls left: ${currentPlayer.rollsLeft}. Roll your dice!`;
            logGameEvent(`It's ${currentPlayer.name}'s turn.`, 'turn');
            togglePlayerControls(currentPlayerIndex);
        }

        function togglePlayerControls(activePlayerIdx) {
            rollDiceBtn1.disabled = (activePlayerIdx !== 0);
            lockDiceBtn1.disabled = (activePlayerIdx !== 0);
            mindAttackTargetBtns[0].disabled = (activePlayerIdx !== 0);
            clearFormulaBtns[0].disabled = (activePlayerIdx !== 0);

            rollDiceBtn2.disabled = (activePlayerIdx !== 1);
            lockDiceBtn2.disabled = (activePlayerIdx !== 1);
            mindAttackTargetBtns[1].disabled = (activePlayerIdx !== 1);
            clearFormulaBtns[1].disabled = (activePlayerIdx !== 1);
        }

        function updateUI() {
            const player1 = players[0];
            const player2 = players[1];

            player1ScoreEl.textContent = player1.score;
            player2ScoreEl.textContent = player2.score;
            player1RollsEl.textContent = player1.rollsLeft;
            player2RollsEl.textContent = player2.rollsLeft;

            renderDice(player1DiceContainer, player1);
            renderDice(player2DiceContainer, player2);

            // Update Mind Attack display for active player
            const activeDisplay = players[0] === players[currentPlayerIndex] ? mindAttackDisplay1 : mindAttackDisplay2;
            const inactiveDisplay = players[0] === players[currentPlayerIndex] ? mindAttackDisplay2 : mindAttackDisplay1;

            activeDisplay.querySelector('span').textContent = currentFormulaParts.join('');
            inactiveDisplay.querySelector('span').textContent = ''; // Clear inactive player's display

            // Disable/enable mind attack buttons based on active player
            mindAttackTargetBtns[0].disabled = (currentPlayerIndex !== 0);
            mindAttackTargetBtns[1].disabled = (currentPlayerIndex !== 1);
            clearFormulaBtns[0].disabled = (currentPlayerIndex !== 0);
            clearFormulaBtns[1].disabled = (currentPlayerIndex !== 1);
        }

        function renderDice(container, player) {
            container.innerHTML = ''; // Clear previous dice
            player.dice.forEach(die => {
                const dieEl = document.createElement('div');
                dieEl.className = `die ${die.locked ? 'locked' : ''}`;
                dieEl.id = die.id; // Assign ID to the die element
                dieEl.innerHTML = `${die.value}<span class="die-type">${die.type.toUpperCase()}</span>`;
                dieEl.addEventListener('click', () => {
                    if (!mindAttackMode) { // Only allow locking/unlocking if not in mind attack mode
                        player.lockDie(die.id);
                        updateUI();
                    } else if (activeMindAttackPlayerIndex !== player.id) { // Allow selecting own die as target during mind attack
                        // This logic is for within the modal, not main game screen.
                        // The main screen dice are only for locking/unlocking normally.
                        // Mind attack target selection happens in the modal.
                    }
                });
                container.appendChild(dieEl);
            });
        }

        function logGameEvent(message, type = 'general') {
            const p = document.createElement('p');
            p.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
            if (type === 'system') {
                p.classList.add('log-entry-highlight');
            }
            gameLogEl.prepend(p); // Add to the top
        }

        function checkGameEnd() {
            const player1 = players[0];
            const player2 = players[1];

            if (player1.rollsLeft === 0 && player2.rollsLeft === 0) {
                player1.score = player1.calculateScore();
                player2.score = player2.calculateScore();
                messageEl.textContent = `Game Over! Player 1 Score: ${player1.score}, Player 2 Score: ${player2.score}.`;
                if (player1.score > player2.score) {
                    messageEl.textContent += " Player 1 Wins!";
                    logGameEvent("Player 1 wins the game!", 'system');
                } else if (player2.score > player1.score) {
                    messageEl.textContent += " Player 2 Wins!";
                    logGameEvent("Player 2 wins the game!", 'system');
                } else {
                    messageEl.textContent += " It's a Tie!";
                    logGameEvent("The game is a tie!", 'system');
                }
                // Disable roll/lock buttons
                rollDiceBtn1.disabled = true;
                lockDiceBtn1.disabled = true;
                rollDiceBtn2.disabled = true;
                lockDiceBtn2.disabled = true;
                mindAttackTargetBtns.forEach(btn => btn.disabled = true);
                clearFormulaBtns.forEach(btn => btn.disabled = true);
                return true;
            }
            return false;
        }

        // Event Listeners for main game buttons
        rollDiceBtn1.addEventListener('click', () => {
            if (players[0].rollDice()) {
                players[0].score = players[0].calculateScore();
                updateUI();
                if (!checkGameEnd()) {
                    switchTurns();
                }
            }
        });

        lockDiceBtn1.addEventListener('click', () => {
            // Locking/unlocking handled by click on individual die elements
            messageEl.textContent = "Click on a die to lock or unlock it.";
        });

        rollDiceBtn2.addEventListener('click', () => {
            if (players[1].rollDice()) {
                players[1].score = players[1].calculateScore();
                updateUI();
                if (!checkGameEnd()) {
                    switchTurns();
                }
            }
        });

        lockDiceBtn2.addEventListener('click', () => {
            // Locking/unlocking handled by click on individual die elements
            messageEl.textContent = "Click on a die to lock or unlock it.";
        });

        // Mind Attack Logic
        mindAttackTargetBtns.forEach(btn => {
            btn.addEventListener('click', (event) => {
                activeMindAttackPlayerIndex = parseInt(event.target.dataset.player);
                mindAttackMode = true;
                openTargetSelectionModal(activeMindAttackPlayerIndex);
                messageEl.textContent = `${players[activeMindAttackPlayerIndex].name}: Select a target die for your Mind Attack.`;
                updateUI();
            });
        });

        clearFormulaBtns.forEach(btn => {
            btn.addEventListener('click', (event) => {
                if (parseInt(event.target.dataset.player) === currentPlayerIndex) {
                    currentFormulaParts = [];
                    renderMindAttackDisplay();
                    messageEl.textContent = "Mind attack formula cleared.";
                }
            });
        });

        function openTargetSelectionModal(attackingPlayerIndex) {
            targetDiceGrid.innerHTML = '';
            selectedTargetDie = null;
            confirmTargetBtn.disabled = true;

            const targetPlayerIndex = 1 - attackingPlayerIndex; // The player being attacked
            const targetPlayer = players[targetPlayerIndex];

            targetPlayer.dice.forEach(die => {
                const targetDieEl = document.createElement('div');
                targetDieEl.className = 'target-die';
                targetDieEl.innerHTML = `${die.value}<span class="die-type">${die.type.toUpperCase()}</span><span class="target-die-player">P${targetPlayerIndex + 1}</span>`;
                targetDieEl.dataset.playerIndex = targetPlayerIndex;
                targetDieEl.dataset.dieId = die.id;
                targetDieEl.addEventListener('click', () => {
                    // Remove 'selected-target' from previously selected die
                    document.querySelectorAll('.target-die').forEach(d => d.classList.remove('selected-target'));
                    // Add 'selected-target' to the clicked die
                    targetDieEl.classList.add('selected-target');
                    selectedTargetDie = {
                        playerIndex: targetPlayerIndex,
                        dieId: die.id,
                        value: die.value // Store value for easy access
                    };
                    confirmTargetBtn.disabled = false;
                });
                targetDiceGrid.appendChild(targetDieEl);
            });

            targetSelectionModal.style.display = 'flex'; // Show modal
        }

        closeButton.addEventListener('click', () => {
            targetSelectionModal.style.display = 'none';
            mindAttackMode = false;
            selectedTargetDie = null;
            currentFormulaParts = [];
            activeMindAttackPlayerIndex = -1;
            messageEl.textContent = "Mind Attack cancelled. Back to regular game.";
            updateUI(); // Refresh UI to clear Mind Attack state
        });

        window.addEventListener('click', (event) => {
            if (event.target == targetSelectionModal) {
                targetSelectionModal.style.display = 'none';
                mindAttackMode = false;
                selectedTargetDie = null;
                currentFormulaParts = [];
                activeMindAttackPlayerIndex = -1;
                messageEl.textContent = "Mind Attack cancelled. Back to regular game.";
                updateUI();
            }
        });

        confirmTargetBtn.addEventListener('click', () => {
            if (selectedTargetDie) {
                targetSelectionModal.style.display = 'none';
                messageEl.textContent = `${players[activeMindAttackPlayerIndex].name}: Target selected: Player ${selectedTargetDie.playerIndex + 1}'s ${players[selectedTargetDie.playerIndex].dice.find(d => d.id === selectedTargetDie.dieId).type} with value ${selectedTargetDie.value}. Now, enter your formula!`;
                logGameEvent(`${players[activeMindAttackPlayerIndex].name} selected Player ${selectedTargetDie.playerIndex + 1}'s ${selectedTargetDie.value} die as target.`, 'mind-attack');
                updateUI(); // Refresh UI
            }
        });

        function handleMindAttackFormulaInput(input) {
            const targetDie = players[selectedTargetDie.playerIndex].dice.find(d => d.id === selectedTargetDie.dieId);
            if (!targetDie) {
                messageEl.textContent = "No target die selected for Mind Attack. Please select one first.";
                return;
            }

            // Prevent leading operators
            if (currentFormulaParts.length === 0 && OPERATORS.includes(input) && input !== '(') {
                messageEl.textContent = "Formula cannot start with an operator (except parenthesis).";
                return;
            }

            // Prevent multiple decimal points in a single number
            if (input === '.') {
                const lastPart = currentFormulaParts[currentFormulaParts.length - 1];
                if (lastPart && NUMBERS.includes(lastPart[lastPart.length - 1]) && lastPart.includes('.')) {
                    messageEl.textContent = "Cannot add another decimal point to the current number.";
                    return;
                }
            }

            // Simple logic to merge numbers, keep operators separate
            const lastPart = currentFormulaParts[currentFormulaParts.length - 1];
            if (NUMBERS.includes(input) && lastPart && (NUMBERS.includes(lastPart) || (lastPart.endsWith('.') && NUMBERS.includes(input)))) {
                currentFormulaParts[currentFormulaParts.length - 1] += input;
            } else {
                currentFormulaParts.push(input);
            }
            renderMindAttackDisplay();
            messageEl.textContent = `Formula: ${currentFormulaParts.join('')}. Try to reach ${targetDie.value}.`;
        }


        function renderMindAttackDisplay() {
            const displayEl = players[activeMindAttackPlayerIndex] === players[0] ? mindAttackDisplay1 : mindAttackDisplay2;
            displayEl.querySelector('span').textContent = currentFormulaParts.join('');
        }

        function executeMindAttack() {
            if (!selectedTargetDie) {
                messageEl.textContent = "No target die selected for Mind Attack.";
                return;
            }
            if (currentFormulaParts.length === 0) {
                messageEl.textContent = "Mind Attack formula is empty. Please enter a formula.";
                return;
            }

            const formula = currentFormulaParts.join('');
            let result;
            try {
                // Basic validation: prevent empty parentheses or consecutive operators
                if (formula.includes("()") || /[+\-*/]{2,}/.test(formula)) {
                    throw new Error("Invalid formula syntax.");
                }
                // Evaluate the formula, using a safe evaluation method like Function constructor
                // WARNING: eval() is dangerous. For a real app, use a dedicated math expression parser.
                result = new Function('return ' + formula)();
            } catch (error) {
                messageEl.textContent = `Mind Attack failed: Invalid formula. (${error.message})`;
                logGameEvent(`${players[activeMindAttackPlayerIndex].name}'s Mind Attack failed: Invalid formula.`, 'error');
                resetMindAttack();
                return;
            }

            const targetPlayer = players[selectedTargetDie.playerIndex];
            const targetDie = targetPlayer.dice.find(d => d.id === selectedTargetDie.dieId);

            if (result === targetDie.value) {
                // Reduce target die value by 1, minimum 1
                targetDie.value = Math.max(1, targetDie.value - 1);
                messageEl.textContent = `Mind Attack successful! Player ${selectedTargetDie.playerIndex + 1}'s ${targetDie.type} die value reduced to ${targetDie.value}.`;
                logGameEvent(`${players[activeMindAttackPlayerIndex].name}'s Mind Attack SUCCESS! Player ${selectedTargetDie.playerIndex + 1}'s ${targetDie.type} reduced to ${targetDie.value}.`, 'mind-attack-success');
            } else {
                // Attacking player loses 5 points, minimum 0
                players[activeMindAttackPlayerIndex].score = Math.max(0, players[activeMindAttackPlayerIndex].score - 5);
                messageEl.textContent = `Mind Attack failed! Formula result ${result} did not match target ${targetDie.value}. ${players[activeMindAttackPlayerIndex].name} loses 5 points.`;
                logGameEvent(`${players[activeMindAttackPlayerIndex].name}'s Mind Attack FAILED. Result ${result} vs target ${targetDie.value}. Score reduced by 5.`, 'mind-attack-fail');
            }

            // Update scores after potential changes
            players[0].score = players[0].calculateScore();
            players[1].score = players[1].calculateScore();

            resetMindAttack();
            updateUI();
            if (!checkGameEnd()) {
                switchTurns();
            }
        }

        function resetMindAttack() {
            mindAttackMode = false;
            selectedTargetDie = null;
            currentFormulaParts = [];
            activeMindAttackPlayerIndex = -1;
            mindAttackDisplay1.querySelector('span').textContent = '';
            mindAttackDisplay2.querySelector('span').textContent = '';
        }

        // Keyboard input for Mind Attack formula (listens on the whole document)
        document.addEventListener('keydown', (event) => {
            if (mindAttackMode && activeMindAttackPlayerIndex !== -1 && selectedTargetDie) {
                const key = event.key.toUpperCase();
                if (NUMBERS.includes(key) || (key === '.' && !currentFormulaParts.includes('.'))) { // Is it a number or a decimal point?
                    handleMindAttackFormulaInput(key);
                    event.preventDefault(); // Prevent default typing behavior
                } else if (OPERATORS.includes(key) || PARENTHESES.includes(key)) { // Is it an operator or parenthesis?
                    handleMindAttackFormulaInput(key);
                    event.preventDefault(); 
                } else if (key === 'BACKSPACE') {
                    if (currentFormulaParts.length > 0) {
                        currentFormulaParts.pop();
                        renderMindAttackDisplay();
                        const targetDie = players[selectedTargetDie.playerIndex].dice.find(d => d.id === selectedTargetDie.dieId);
                        messageEl.textContent = `Last part removed. Continue building formula to match ${targetDie.type.toUpperCase()} (${targetDie.value}).`;
                    } else {
                        messageEl.textContent = "Formula is already empty.";
                    }
                    event.preventDefault();
                } else if (key === 'ENTER') {
                    executeMindAttack();
                    event.preventDefault();
                } else {
                    // Ignore other keys
                    event.preventDefault();
                }
                updateUI(); // Keep UI updated with formula changes
            }
        });


        // Layout preference management
        function setLayoutPreference(layout) {
            if (layout === 'side') {
                gameContainer.classList.remove('log-bottom');
                gameContainer.classList.add('log-side');
                logPositionToggle.checked = true;
            } else {
                gameContainer.classList.remove('log-side');
                gameContainer.classList.add('log-bottom');
                logPositionToggle.checked = false;
            }
            localStorage.setItem('gameLayout', layout); // Save preference
        }

        // Load layout preference on start
        const savedLayout = localStorage.getItem('gameLayout');
        if (savedLayout) {
            setLayoutPreference(savedLayout);
        } else {
            // Default to side if no preference saved
            setLayoutPreference('side');
        }


        // Layout toggle listener
        logPositionToggle.addEventListener('change', (event) => {
            setLayoutPreference(event.target.checked ? 'side' : 'bottom');
        });

        // NEW CODE FOR "NEW GAME" BUTTON START
        // New Game button listener
        const newGameButton = document.getElementById('newGameBtn');
        if (newGameButton) {
            newGameButton.addEventListener('click', () => {
                initGame(true); // Start a brand new game with scores reset
                messageEl.textContent = "New game started!"; // Optional: provide user feedback
                updateUI(); // Update the UI to reflect the new game state
            });
        }
        // NEW CODE FOR "NEW GAME" BUTTON END

        // Initial game setup
        initGame(true); // Start a brand new game with scores reset
    </script>
</body>
</html>
