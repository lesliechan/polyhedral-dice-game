<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Polyhedral Dice Game</title>
    <style>
        /* CSS goes here */
        body {
            font-family: 'Arial', sans-serif;
            background-color: #2c3e50;
            color: #ecf0f1;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-start;
            min-height: 100vh;
            margin: 0;
            padding: 10px;
            box-sizing: border-box;
            overflow-x: hidden;
        }

        /* UPDATED: Game Header */
        .game-header {
            background-color: #34495e;
            border-radius: 10px;
            padding: 10px 20px; /* Reduced padding */
            box-shadow: 0 0 15px rgba(0, 0, 0, 0.4);
            text-align: center;
            width: 100%;
            max-width: 900px;
            margin-bottom: 15px; /* Reduced margin */
            box-sizing: border-box;
        }

        .game-header h1 {
            color: #f1c40f;
            margin: 0 0 10px 0; /* Reduced margin */
            font-size: 2em; /* Smaller font size */
        }

        .score-container {
            display: flex;
            justify-content: space-around;
            gap: 5px; /* Reduced gap */
            flex-wrap: wrap;
        }

        .player-score-panel {
            background-color: #2980b9;
            border-radius: 5px;
            padding: 6px 12px; /* Reduced padding */
            font-size: 1.1em; /* Slightly smaller font */
            font-weight: bold;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        #player0-score, #player1-score {
            color: #f1c40f;
            font-size: 1.2em;
        }

        /* NEW: Layout Controls */
        .layout-controls {
            margin-bottom: 15px;
            font-size: 0.9em;
            display: flex;
            gap: 15px;
            align-items: center;
            flex-wrap: wrap;
            justify-content: center;
        }
        .layout-controls label {
            color: #ecf0f1;
        }
        .layout-controls input[type="radio"] {
            margin-right: 5px;
        }

        /* NEW: Main Content Wrapper for Layout */
        .main-content-wrapper {
            display: flex;
            flex-direction: column; /* Default: column (log at bottom) */
            width: 100%;
            max-width: 900px; /* Aligned with game-container's max-width */
            align-items: center;
            gap: 20px; /* Space between game and log when stacked */
        }

        /* Side layout specific styles */
        .main-content-wrapper.log-side {
            flex-direction: row; /* Change to row for side layout */
            justify-content: center;
            align-items: flex-start; /* Align items to the top */
            max-width: 1200px; /* Wider for side layout */
            margin-top: 0; /* Adjust margin if needed */
        }

        /* Game container styles */
        .game-container {
            background-color: #34495e;
            border-radius: 10px;
            padding: 30px;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.5);
            text-align: center;
            width: 100%; /* Default width for column layout */
            max-width: 900px;
            position: relative;
            box-sizing: border-box;
            flex-shrink: 0; /* Prevent shrinking */
        }
        .main-content-wrapper.log-side .game-container {
            width: 65%; /* Allocate space for game board */
            max-width: 900px; /* Keep consistent max width for game board */
            margin-bottom: 0; /* No bottom margin when side by side */
        }

        /* Game log container styles */
        .game-log-container {
            background-color: #34495e;
            border-radius: 10px;
            padding: 15px 20px;
            box-shadow: 0 0 15px rgba(0, 0, 0, 0.4);
            width: 100%; /* Default width for column layout */
            max-width: 900px;
            box-sizing: border-box;
            flex-shrink: 0; /* Prevent shrinking */
            max-height: 200px; /* Default max-height for bottom log */
        }
        .main-content-wrapper.log-side .game-log-container {
            width: 35%; /* Allocate space for log */
            max-width: 350px; /* Max width for log when on side */
            min-width: 250px; /* Ensure log is not too narrow */
            max-height: 700px; /* Allow more height for log on side */
            margin-top: 0; /* No top margin when side by side */
        }
        .game-log-container h3 {
            color: #ecf0f1;
            margin-top: 0;
            margin-bottom: 10px;
            font-size: 1.5em;
        }

        #game-log {
            background-color: #2c3e50;
            border-radius: 5px;
            padding: 10px;
            max-height: 100%; /* Take full height of container */
            overflow-y: auto; /* Enable vertical scrolling */
            border: 1px solid #4a627a;
            color: #bdc3c7;
            font-size: 0.9em; /* Default font size for bottom log */
            line-height: 1.4;
            text-align: left;
        }
        /* Smaller text for side log */
        .main-content-wrapper.log-side #game-log {
            font-size: 0.8em;
        }

        /* END NEW: Layout */

        .players-area {
            display: flex;
            justify-content: space-around;
            margin-bottom: 30px;
            flex-wrap: wrap;
            gap: 20px;
        }

        .player-panel {
            background-color: #2980b9;
            border-radius: 8px;
            padding: 15px;
            width: 48%;
            min-width: 350px;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.3);
            transition: background-color 0.3s ease;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            position: relative;
            box-sizing: border-box;
        }

        .player-panel.player--active {
            background-color: #e67e22;
            box-shadow: 0 0 15px rgba(241, 196, 15, 0.7);
        }

        .player-panel h2 {
            margin-top: 0;
            color: #ecf0f1;
            font-size: 1.8em;
        }

        .dice-pool-label {
            font-size: 1.1em;
            color: #bdc3c7;
            margin-top: 10px;
            margin-bottom: 5px;
        }

        .dice-pool {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 10px;
            min-height: 80px;
        }

        .die-item {
            position: relative;
            width: 60px;
            height: 60px;
            /* Default background, will be overridden by type-specific class */
            background-color: #ecf0f1;
            border-radius: 8px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            font-size: 1.2em;
            font-weight: bold;
            color: #34495e; /* Default text color for light backgrounds */
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
            cursor: pointer;
            transition: transform 0.1s ease-in-out, border 0.1s ease-in-out, box-shadow 0.1s ease-in-out;
            border: 2px solid transparent;
            z-index: 1;
            box-sizing: border-box;
        }

        /* NEW: Dice Colors */
        .die-item.d4 { background-color: #A3E4D7; } /* Light Teal */
        .die-item.d6 { background-color: #F9E79F; } /* Light Yellow */
        .die-item.d8 { background-color: #D2B4DE; } /* Light Purple */
        .die-item.d10 { background-color: #F5B7B1; } /* Light Coral */
        .die-item.d12 { background-color: #A9CCE3; } /* Light Blue */
        .die-item.d20 { background-color: #FADBD8; } /* Light Pink */

        /* Ensure text is dark on light backgrounds */
        .die-item.d4 .die-value, .die-item.d4 .die-type, .die-item.d4 .die-label,
        .die-item.d6 .die-value, .die-item.d6 .die-type, .die-item.d6 .die-label,
        .die-item.d8 .die-value, .die-item.d8 .die-type, .die-item.d8 .die-label,
        .die-item.d10 .die-value, .die-item.d10 .die-type, .die-item.d10 .die-label,
        .die-item.d12 .die-value, .die-item.d12 .die-type, .die-item.d12 .die-label,
        .die-item.d20 .die-value, .die-item.d20 .die-type, .die-item.d20 .die-label {
            color: #34495e; /* Dark text for all light backgrounds */
        }
        /* Selected/highlighted states */
        .die-item.selected-attack {
            border: 4px solid #f1c40f;
            transform: scale(1.08);
            box-shadow: 0 0 10px rgba(241, 196, 15, 0.7);
        }

        .die-item.selected-target {
            border: 4px solid #e74c3c;
            transform: scale(1.08);
            box-shadow: 0 0 10px rgba(231, 76, 60, 0.7);
        }

        .die-item.selected-attack .die-value,
        .die-item.selected-target .die-value {
            font-weight: bolder;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5);
        }

        .die-item.mind-attack-selectable {
            border: 2px solid #9b59b6;
            box-shadow: 0 0 8px rgba(155, 89, 182, 0.7);
        }
        .die-item.mind-attack-selectable .die-value {
             font-weight: bold;
        }

        .die-type {
            font-size: 0.7em;
            color: #7f8c8d; /* Original color might be too light on some backgrounds, adjust if needed */
            position: absolute;
            top: 5px;
            left: 5px;
        }

        .die-label {
            font-size: 1.1em;
            font-weight: bolder;
            color: #3498db; /* Original color might be too light on some backgrounds, adjust if needed */
            position: absolute;
            bottom: -10px;
            background-color: #2c3e50;
            padding: 2px 5px;
            border-radius: 4px;
            z-index: 10;
        }

        .die-value {
            font-size: 1.5em;
        }

        .captured-dice-label {
            font-size: 1.1em;
            color: #bdc3c7;
            margin-top: 15px;
            margin-bottom: 5px;
        }

        .captured-dice-pool {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 5px;
            min-height: 30px;
        }

        .captured-die-item {
            width: 30px;
            height: 30px;
            background-color: #27ae60;
            border-radius: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.8em;
            font-weight: bold;
            color: white;
            box-shadow: 0 1px 2px rgba(0, 0, 0, 0.2);
            transition: transform 0.3s ease;
        }

        .controls {
            margin-top: 30px;
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 10px;
        }

        button {
            background-color: #27ae60;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            font-size: 1em;
            cursor: pointer;
            transition: background-color 0.2s ease, transform 0.1s ease;
        }

        button:hover:not(:disabled) {
            background-color: #2ecc71;
            transform: translateY(-2px);
        }

        button:disabled {
            background-color: #7f8c8d;
            cursor: not-allowed;
        }

        #mindAttackInputContainer {
            margin-top: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 10px;
            width: 100%;
        }

        #mindAttackDisplay {
            min-height: 40px;
            background-color: #ecf0f1;
            color: #34495e;
            border-radius: 5px;
            padding: 8px 15px;
            width: 80%;
            max-width: 600px;
            text-align: center;
            font-size: 1.2em;
            font-weight: bold;
            display: flex;
            align-items: center;
            justify-content: center;
            overflow-x: auto;
            white-space: nowrap;
            box-shadow: inset 0 1px 3px rgba(0,0,0,0.2);
            box-sizing: border-box;
        }

        .mind-attack-buttons {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 5px;
            margin-top: 10px;
        }

        .mind-attack-buttons .formula-btn {
            background-color: #3498db;
            padding: 8px 15px;
            font-size: 1em;
            min-width: 45px;
            text-align: center;
        }

        .mind-attack-buttons .formula-btn:hover:not(:disabled) {
            background-color: #5dade2;
        }

        #btnFormulaClear, #btnFormulaBackspace {
            background-color: #c0392b;
            padding: 8px 15px;
            font-size: 1em;
        }

        #btnFormulaClear:hover, #btnFormulaBackspace:hover {
            background-color: #e74c3c;
        }

        .message {
            font-size: 1.2em;
            font-weight: bold;
            color: #f1c40f;
            margin-top: 20px;
            min-height: 30px;
        }

        .log-entry {
            margin-bottom: 5px;
            border-bottom: 1px dotted #4a627a;
            padding-bottom: 5px;
        }
        .log-entry:last-child {
            margin-bottom: 0;
            border-bottom: none;
        }
        .log-entry.info { color: #bdc3c7; }
        .log-entry.win { color: #2ecc71; font-weight: bold; }
        .log-entry.error { color: #e74c3c; font-weight: bold; }

        /* Style for numeric formula parts in log */
        .log-entry .formula-part {
            padding: 1px 3px;
            border-radius: 2px;
            display: inline-block; /* Allows padding and background */
            font-weight: bold;
            box-shadow: 0 1px 2px rgba(0,0,0,0.2);
            margin: 0 1px; /* Small space between parts */
            white-space: nowrap; /* Keep parts together */
        }
        .log-entry .formula-part span {
            /* To ensure consistency with the direct text parts */
            color: inherit;
        }

        .game-over-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.8);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            color: white;
            font-size: 2em;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
        }

        .game-over-overlay button {
            margin-top: 30px;
            font-size: 1.2em;
            padding: 15px 30px;
        }

        /* Animation CSS (unchanged from previous) */
        @keyframes rotatePulse {
            0% { transform: rotateY(0deg) scale(1); }
            50% { transform: rotateY(360deg) scale(1.1); }
            100% { transform: rotateY(720deg) scale(1); }
        }

        .die-attacking-animation {
            animation: rotatePulse 0.6s ease-out forwards;
        }

        .die-capture-animation {
            position: fixed !important;
            animation: captureMove 0.8s ease-in-out forwards;
            z-index: 999;
        }

        @keyframes captureMove {
            0% {
                transform: translate(0, 0) scale(1);
                opacity: 1;
            }
            70% {
                transform: translate(var(--dx), var(--dy)) scale(0.6);
                opacity: 0.8;
            }
            100% {
                transform: translate(var(--dx), var(--dy)) scale(0.3);
                opacity: 0;
            }
        }

        /* --- MEDIA QUERIES FOR RESPONSIVENESS --- */

        /* For screens smaller than 1200px (primary breakpoint for side-log layout) */
        @media screen and (max-width: 1200px) {
            .main-content-wrapper.log-side {
                flex-direction: column; /* Stack back to column for smaller screens */
                max-width: 900px; /* Revert to column max-width */
            }
            .main-content-wrapper.log-side .game-container,
            .main-content-wrapper.log-side .game-log-container {
                width: 100%; /* Full width when stacked */
                max-width: 900px; /* Match main container */
                margin-bottom: 20px; /* Re-add margin */
            }
            .main-content-wrapper.log-side .game-log-container {
                max-height: 200px; /* Revert max height */
            }
            .main-content-wrapper.log-side #game-log {
                font-size: 0.9em; /* Revert font size */
            }
        }


        /* For screens smaller than 800px (e.g., larger tablets in portrait, small laptops) */
        @media screen and (max-width: 800px) {
            .game-header, .game-container, .game-log-container {
                padding: 15px; /* Reduce padding for smaller screens */
            }

            .game-header h1 {
                font-size: 1.8em; /* Further smaller title */
            }

            .player-score-panel {
                font-size: 1.0em;
            }

            #player0-score, #player1-score {
                font-size: 1.1em;
            }

            .players-area {
                flex-direction: column; /* Stack player panels vertically */
                align-items: center; /* Center panels */
                gap: 15px; /* Reduce gap between stacked panels */
            }

            .player-panel {
                width: 95%; /* Take almost full width */
                min-width: unset; /* IMPORTANT: Remove fixed minimum width */
                max-width: 450px; /* Optional: Cap max width for better centering on slightly larger "small" screens */
            }

            .die-item {
                width: 55px; /* Slightly smaller dice */
                height: 55px;
                font-size: 1.1em;
            }

            .die-label {
                font-size: 1em; /* Adjust label size */
                bottom: -8px;
            }

            .die-type {
                font-size: 0.65em; /* Adjust type label size */
            }

            button {
                padding: 8px 15px; /* Smaller button padding */
                font-size: 0.95em;
            }

            .message {
                font-size: 1.1em;
            }
            
            #game-log {
                max-height: 150px; /* Reduce log height on smaller screens */
                font-size: 0.85em;
            }

            .main-content-wrapper { /* Ensure consistency when stacked */
                max-width: 800px;
            }

            #mindAttackDisplay {
                width: 90%; /* Ensure display fits well */
            }
        }

        /* For screens smaller than 500px (e.g., most smartphones) */
        @media screen and (max-width: 500px) {
            .game-header, .game-container, .game-log-container {
                padding: 10px;
            }

            .game-header h1 {
                font-size: 1.6em;
            }

            .player-score-panel {
                font-size: 0.9em;
                padding: 5px 8px;
            }

            #player0-score, #player1-score {
                font-size: 1.0em;
            }

            .game-header .score-container {
                flex-direction: column; /* Stack scores vertically on very small screens */
            }

            .player-panel {
                padding: 10px;
                width: 100%; /* Take full width on very small screens */
            }

            .player-panel h2 {
                font-size: 1.6em;
            }

            .dice-pool-label, .captured-dice-label {
                font-size: 1em;
            }

            .die-item {
                width: 48px; /* Make dice even smaller */
                height: 48px;
                font-size: 1em;
            }

            .die-label {
                font-size: 0.85em; /* Even smaller label */
                bottom: -6px; /* Adjust position */
            }
            .die-type {
                font-size: 0.55em;
            }

            .die-value {
                font-size: 1.3em;
            }

            .captured-die-item {
                width: 25px;
                height: 25px;
                font-size: 0.7em;
            }

            .controls button,
            .mind-attack-buttons .formula-btn,
            #btnSubmitMindAttack {
                padding: 7px 12px; /* Even smaller buttons */
                font-size: 0.85em;
            }

            .message {
                font-size: 0.95em;
            }

            #game-log {
                max-height: 120px; /* Further reduce log height */
                font-size: 0.8em;
            }

            .game-over-overlay {
                font-size: 1.5em;
            }
            .game-over-overlay button {
                font-size: 1em;
                padding: 10px 20px;
            }
        }

        /* Further small adjustments for very narrow screens if needed */
        @media screen and (max-width: 350px) {
             .die-item {
                width: 42px; /* Smallest dice */
                height: 42px;
                font-size: 0.9em;
            }
            .die-label {
                font-size: 0.75em;
                bottom: -5px;
            }
             .die-type {
                font-size: 0.5em;
            }
        }
    </style>
</head>
<body>
    <div class="game-header">
        <h1>Polyhedral Dice Game</h1>
        <div class="score-container">
            <div class="player-score-panel player--0-score">
                Player 1: <span id="player0-score">0</span>
            </div>
            <div class="player-score-panel player--1-score">
                Player 2: <span id="player1-score">0</span>
            </div>
        </div>
    </div>

    <div class="layout-controls">
        <label>Game Log Position:</label>
        <input type="radio" id="log-bottom" name="log-position" value="bottom" checked>
        <label for="log-bottom">Bottom</label>
        <input type="radio" id="log-side" name="log-position" value="side">
        <label for="log-side">Side</label>
    </div>

    <div class="main-content-wrapper" id="main-content-wrapper">
        <div class="game-container" id="game-container">
            <div class="players-area">
                <div class="player-panel player--0">
                    <h2>Player 1</h2>
                    <div class="dice-pool-label">Your Dice Pool:</div>
                    <div class="dice-pool" id="player0-dice-pool"></div>
                    <div class="captured-dice-label">Captured Dice:</div>
                    <div class="captured-dice-pool" id="player0-captured-dice"></div>
                </div>
                <div class="player-panel player--1">
                    <h2>Player 2</h2>
                    <div class="dice-pool-label">Your Dice Pool:</div>
                    <div class="dice-pool" id="player1-dice-pool"></div>
                    <div class="captured-dice-label">Captured Dice:</div>
                    <div class="captured-dice-pool" id="player1-captured-dice"></div>
                </div>
            </div>

            <div class="controls">
                <button id="btnInitialRoll">Initial Roll (Determine First Player)</button>
                <button id="btnStrengthAttack" disabled>Strength Attack</button>
                <button id="btnMindAttack" disabled>Mind Attack</button>
                <button id="btnPass" disabled>Pass</button>
                <button id="btnNewGame">New Game</button>
            </div>

            <div id="mindAttackInputContainer" style="display: none;">
                <div id="mindAttackDisplay"></div>
                <div class="mind-attack-buttons">
                    <button class="formula-btn" data-value="(">(</button>
                    <button class="formula-btn" data-value=")">)</button>
                    <button class="formula-btn" data-value="+">+</button>
                    <button class="formula-btn" data-value="-">-</button>
                    <button class="formula-btn" data-value="*">*</button>
                    <button class="formula-btn" data-value="/">/</button>
                    <button id="btnFormulaClear">Clear</button>
                    <button id="btnFormulaBackspace">Bksp</button>
                </div>
                <button id="btnSubmitMindAttack">Submit Mind Attack</button>
            </div>

            <div class="message" id="message">Click "Initial Roll" to begin!</div>
        </div>

        <div class="game-log-container" id="game-log-container">
            <h3>Game Log</h3>
            <div id="game-log">
                </div>
        </div>
    </div> <div id="gameOverOverlay" class="game-over-overlay" style="display: none;">
        <p id="gameOverMessage"></p>
        <button id="btnPlayAgain">Play Again</button>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/mathjs@12.4.3/lib/browser/math.min.js"></script>

    <script>
        // --- DOM Elements ---
        const player0Panel = document.querySelector('.player--0');
        const player1Panel = document.querySelector('.player--1');
        const player0DicePoolEl = document.getElementById('player0-dice-pool');
        const player1DicePoolEl = document.getElementById('player1-dice-pool');
        const player0CapturedDiceEl = document.getElementById('player0-captured-dice');
        const player1CapturedDiceEl = document.getElementById('player1-captured-dice');
        const btnInitialRoll = document.getElementById('btnInitialRoll');
        const btnStrengthAttack = document.getElementById('btnStrengthAttack');
        const btnMindAttack = document.getElementById('btnMindAttack');
        const btnPass = document.getElementById('btnPass');
        const btnNewGame = document.getElementById('btnNewGame');
        const mindAttackInputContainer = document.getElementById('mindAttackInputContainer');
        const mindAttackDisplay = document.getElementById('mindAttackDisplay');
        const formulaButtons = document.querySelectorAll('.formula-btn');
        const btnFormulaClear = document.getElementById('btnFormulaClear');
        const btnFormulaBackspace = document.getElementById('btnFormulaBackspace');
        const btnSubmitMindAttack = document.getElementById('btnSubmitMindAttack');
        const messageEl = document.getElementById('message'); // Current instruction message
        const gameOverOverlay = document.getElementById('gameOverOverlay');
        const gameOverMessageEl = document.getElementById('gameOverMessage');
        const btnPlayAgain = document.getElementById('btnPlayAgain');
        const gameContainer = document.querySelector('.game-container'); // Get game container for animation positioning

        // Score and Log Elements
        const player0ScoreEl = document.getElementById('player0-score');
        const player1ScoreEl = document.getElementById('player1-score');
        const gameLogEl = document.getElementById('game-log');

        // NEW: Layout Elements
        const mainContentWrapper = document.getElementById('main-content-wrapper');
        const logBottomRadio = document.getElementById('log-bottom');
        const logSideRadio = document.getElementById('log-side');

        // --- Game State ---
        let players;
        let activePlayerIndex;
        let selectedAttackingDie = null; // { playerIndex, dieId }
        let selectedTargetDie = null;    // { playerIndex, dieId }
        let gamePhase = 'initialRoll'; // 'initialRoll', 'playerTurn', 'mindAttackInput'
        let playing = false;
        let turnCounter = 0;

        let currentFormulaParts = []; // Stores parts of the Mind Attack formula (e.g., ['A', '+', 'B'])

        const DICE_TYPES = ['d4', 'd6', 'd8', 'd10', 'd12', 'd20'];
        const OPERATORS = ['+', '-', '*', '/'];
        const ALPHA = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'; // For die labels

        // NEW: Map for dice colors (for JS logic)
        const DICE_COLORS_MAP = {
            'd4': '#A3E4D7',
            'd6': '#F9E79F',
            'd8': '#D2B4DE',
            'd10': '#F5B7B1',
            'd12': '#A9CCE3',
            'd20': '#FADBD8'
        };


        // --- Sound Effects ---
        const sounds = {
            roll: new Audio('/polyhedral-dice-game/sounds/roll.mp3'),
            click: new Audio('/polyhedral-dice-game/sounds/click.mp3'),
            hit: new Audio('/polyhedral-dice-game/sounds/hit.mp3'),
            zap: new Audio('/polyhedral-dice-game/sounds/zap.mp3'),
            ding: new Audio('/polyhedral-dice-game/sounds/ding.mp3'),
            reroll: new Audio('/polyhedral-dice-game/sounds/reroll.mp3'),
            win: new Audio('/polyhedral-dice-game/sounds/win.mp3')
        };

        function playSound(soundName) {
            if (sounds[soundName]) {
                sounds[soundName].currentTime = 0; // Rewind to start if already playing
                sounds[soundName].play().catch(e => console.error("Error playing sound:", soundName, e));
            }
        }

        // --- Game Initialization ---
        function initGame() {
            players = [
                {
                    name: 'Player 1',
                    dice: [], // Array of { type: 'dX', value: Y, id: 'uniqueId', label: 'A' }
                    captured: [],
                    initialRollValues: [],
                    score: 0
                },
                {
                    name: 'Player 2',
                    dice: [],
                    captured: [],
                    initialRollValues: [],
                    score: 0
                }
            ];

            player0Panel.classList.remove('player--active', 'player--winner');
            player1Panel.classList.remove('player--active', 'player--winner');
            
            player0DicePoolEl.innerHTML = '';
            player1DicePoolEl.innerHTML = '';

            player0CapturedDiceEl.innerHTML = '';
            player1CapturedDiceEl.innerHTML = '';
            
            messageEl.textContent = 'Click "Initial Roll" to begin!';
            mindAttackInputContainer.style.display = 'none';
            gameOverOverlay.style.display = 'none';

            currentFormulaParts = [];
            renderMindAttackDisplay();
            gameLogEl.innerHTML = ''; // Clear game log
            turnCounter = 0;

            btnInitialRoll.disabled = false;
            btnStrengthAttack.disabled = true;
            btnMindAttack.disabled = true;
            btnPass.disabled = true;
            btnSubmitMindAttack.disabled = true;

            gamePhase = 'initialRoll';
            selectedAttackingDie = null;
            selectedTargetDie = null;
            playing = true;

            updateScoreDisplay();
            addGameLogMessage('Game started. Click "Initial Roll" to determine first player.', 'info');
            loadLayoutPreference(); // Load layout preference on init
        }

        function updateScoreDisplay() {
            player0ScoreEl.textContent = players[0].score;
            player1ScoreEl.textContent = players[1].score;
        }

        // UPDATED: Function to add messages to the game log, now supports HTML
        function addGameLogMessage(message, type = 'info', isHtml = false) {
            const logEntry = document.createElement('div');
            logEntry.classList.add('log-entry', type);
            
            const prefix = turnCounter > 0 ? `Turn ${turnCounter}: ` : `Game: `;
            const prefixSpan = document.createElement('span');
            prefixSpan.textContent = prefix;
            logEntry.appendChild(prefixSpan);

            const messageContentSpan = document.createElement('span');
            if (isHtml) {
                messageContentSpan.innerHTML = message;
            } else {
                messageContentSpan.textContent = message;
            }
            logEntry.appendChild(messageContentSpan);

            gameLogEl.prepend(logEntry); // Add to top for reverse chronological order

            // Optionally limit log entries
            while (gameLogEl.children.length > 30) {
                gameLogEl.lastChild.remove();
            }
        }


        // --- Dice Rolling Logic ---
        function rollDie(dieType) {
            const sides = parseInt(dieType.substring(1));
            return Math.floor(Math.random() * sides) + 1;
        }

        function rollAllPlayerDice(playerIndex) {
            players[playerIndex].dice = [];
            players[playerIndex].initialRollValues = [];
            DICE_TYPES.forEach(type => {
                const value = rollDie(type);
                players[playerIndex].dice.push({ type: type, value: value, id: `${type}-${Date.now()}-${Math.random()}` });
                players[playerIndex].initialRollValues.push(value);
            });
            assignDiceLabels(playerIndex); // Assign labels after initial roll
        }

        function reRollSpecificDice(playerIndex, diceToReRoll) {
            diceToReRoll.forEach(die => {
                die.value = rollDie(die.type);
            });
            assignDiceLabels(playerIndex); // Re-assign labels after re-rolling/sorting
        }

        // Assigns A, B, C... labels to dice based on their sorted order
        function assignDiceLabels(playerIndex) {
            players[playerIndex].dice.sort((a, b) => a.value - b.value); // Sort for consistent labels
            players[playerIndex].dice.forEach((die, index) => {
                die.label = ALPHA[index];
            });
        }

        // --- UI Rendering ---
        function renderDicePool(playerIndex) {
            const poolEl = playerIndex === 0 ? player0DicePoolEl : player1DicePoolEl;
            const currentDice = players[playerIndex].dice;

            const existingDieElements = new Map();
            Array.from(poolEl.children).forEach(el => {
                if (el.dataset.dieId) {
                    existingDieElements.set(el.dataset.dieId, el);
                }
            });

            const newOrderElements = [];
            currentDice.forEach((die, index) => {
                let dieEl;
                if (existingDieElements.has(die.id)) {
                    dieEl = existingDieElements.get(die.id);
                    dieEl.querySelector('.die-type').textContent = die.type.toUpperCase();
                    dieEl.querySelector('.die-value').textContent = die.value;
                    dieEl.dataset.dieIndex = index;
                    
                    let labelEl = dieEl.querySelector('.die-label');
                    if (labelEl) {
                        labelEl.textContent = die.label;
                    }
                    existingDieElements.delete(die.id);
                } else {
                    dieEl = document.createElement('div');
                    dieEl.classList.add('die-item');
                    dieEl.dataset.playerIndex = playerIndex;
                    dieEl.dataset.dieId = die.id;
                    dieEl.dataset.dieIndex = index;
                    
                    dieEl.innerHTML = `
                        <span class="die-label">${die.label}</span>
                        <span class="die-type">${die.type.toUpperCase()}</span>
                        <span class="die-value">${die.value}</span>
                    `;
                }
                
                // NEW: Add die type class for coloring
                dieEl.classList.remove(...DICE_TYPES.map(type => `d${type.substring(1)}`)); // Remove all previous color classes
                dieEl.classList.add(`d${die.type.substring(1)}`); // Add specific color class

                dieEl.classList.toggle('selected-attack', selectedAttackingDie && selectedAttackingDie.dieId === die.id);
                dieEl.classList.toggle('selected-target', selectedTargetDie && selectedTargetDie.dieId === die.id);

                dieEl.classList.remove('mind-attack-selectable');
                if (gamePhase === 'mindAttackInput' && playerIndex === activePlayerIndex) {
                    dieEl.classList.add('mind-attack-selectable');
                    dieEl.style.cursor = 'pointer';
                } else if (gamePhase === 'playerTurn') {
                    dieEl.style.opacity = '1';
                    dieEl.style.cursor = 'pointer';
                } else {
                    dieEl.style.opacity = '0.7';
                    dieEl.style.cursor = 'default';
                }
                newOrderElements.push(dieEl);
            });

            existingDieElements.forEach(el => el.remove());

            poolEl.innerHTML = '';
            newOrderElements.forEach(el => poolEl.appendChild(el));
        }

        function renderCapturedDice(playerIndex) {
            const capturedEl = playerIndex === 0 ? player0CapturedDiceEl : player1CapturedDiceEl;
            capturedEl.innerHTML = '';
            players[playerIndex].captured.forEach(die => {
                const capturedDieEl = document.createElement('div');
                capturedDieEl.classList.add('captured-die-item');
                capturedDieEl.textContent = die.type.toUpperCase();
                capturedEl.appendChild(capturedDieEl);
            });
        }

        function renderMindAttackDisplay() {
            mindAttackDisplay.textContent = currentFormulaParts.join(' ');
        }

        // Centralized UI Update
        function updateUI() {
            renderDicePool(0);
            renderDicePool(1);
            renderCapturedDice(0);
            renderCapturedDice(1);
            updateScoreDisplay();

            player0Panel.classList.toggle('player--active', activePlayerIndex === 0);
            player1Panel.classList.toggle('player--active', activePlayerIndex === 1);

            btnInitialRoll.disabled = (gamePhase !== 'initialRoll');
            btnNewGame.disabled = false;

            mindAttackInputContainer.style.display = (gamePhase === 'mindAttackInput' ? 'flex' : 'none');

            const canAttack = selectedAttackingDie && selectedTargetDie &&
                              selectedAttackingDie.playerIndex === activePlayerIndex &&
                              selectedTargetDie.playerIndex !== activePlayerIndex;

            if (gamePhase === 'playerTurn') {
                btnStrengthAttack.disabled = !canAttack;
                btnMindAttack.disabled = !canAttack;
                btnPass.disabled = false;
            } else if (gamePhase === 'mindAttackInput') {
                btnStrengthAttack.disabled = true;
                btnMindAttack.disabled = true;
                btnPass.disabled = true;
                btnSubmitMindAttack.disabled = currentFormulaParts.length === 0;
            } else {
                btnStrengthAttack.disabled = true;
                btnMindAttack.disabled = true;
                btnPass.disabled = true;
            }
        }

        // --- Game Flow Logic ---

        function determineFirstPlayer() {
            playSound('roll');
            rollAllPlayerDice(0);
            rollAllPlayerDice(1);

            let p1Rolls = [...players[0].initialRollValues].sort((a, b) => a - b);
            let p2Rolls = [...players[1].initialRollValues].sort((a, b) => a - b);

            let firstPlayerDetermined = false;
            for (let i = 0; i < DICE_TYPES.length; i++) {
                if (p1Rolls[i] < p2Rolls[i]) {
                    activePlayerIndex = 0;
                    firstPlayerDetermined = true;
                    break;
                } else if (p2Rolls[i] < p1Rolls[i]) {
                    activePlayerIndex = 1;
                    firstPlayerDetermined = true;
                    break;
                }
            }

            if (!firstPlayerDetermined) {
                messageEl.textContent = "It's a tie on initial rolls! Re-rolling to determine first player.";
                addGameLogMessage("Initial roll resulted in a tie. Re-rolling.", "info");
                setTimeout(determineFirstPlayer, 1500);
                return;
            }

            messageEl.textContent = `${players[activePlayerIndex].name} goes first! Choose one of your dice to attack and an opponent's die to target.`;
            addGameLogMessage(`Initial dice roll result: ${players[activePlayerIndex].name} starts.`, 'info');
            gamePhase = 'playerTurn';
            turnCounter = 1;
            updateUI();
        }

        function switchTurn() {
            selectedAttackingDie = null;
            selectedTargetDie = null;
            activePlayerIndex = activePlayerIndex === 0 ? 1 : 0;
            turnCounter++;
            messageEl.textContent = `${players[activePlayerIndex].name}'s turn. Choose one of your dice to attack and an opponent's die to target.`;
            addGameLogMessage(`${players[activePlayerIndex].name}'s turn.`, 'info');
            gamePhase = 'playerTurn';
            updateUI();
            checkPassCondition();
        }

        function checkPassCondition() {
            const currentPlayer = players[activePlayerIndex];
            const opponentPlayer = players[activePlayerIndex === 0 ? 1 : 0];

            if (currentPlayer.dice.length === 0) return;
            if (opponentPlayer.dice.length === 0) return;
        }

        // Event delegation for dice clicks
        player0DicePoolEl.addEventListener('click', handleDieClick);
        player1DicePoolEl.addEventListener('click', handleDieClick);

        function handleDieClick(event) {
            const clickedDieEl = event.target.closest('.die-item');
            if (!clickedDieEl) return;

            const clickedPlayerIndex = parseInt(clickedDieEl.dataset.playerIndex);
            const clickedDieId = clickedDieEl.dataset.dieId;

            const clickedDie = players[clickedPlayerIndex].dice.find(die => die.id === clickedDieId);
            if (!clickedDie) return;

            if (gamePhase === 'playerTurn') {
                playSound('click');
                if (clickedPlayerIndex === activePlayerIndex) {
                    if (selectedAttackingDie && selectedAttackingDie.dieId === clickedDieId) {
                        selectedAttackingDie = null;
                    } else {
                        selectedAttackingDie = { playerIndex: clickedPlayerIndex, dieId: clickedDieId };
                    }
                } else {
                    if (selectedTargetDie && selectedTargetDie.dieId === clickedDieId) {
                        selectedTargetDie = null;
                    } else {
                        selectedTargetDie = { playerIndex: clickedPlayerIndex, dieId: clickedDieId };
                    }
                }
                messageEl.textContent = `${players[activePlayerIndex].name}, select your attacking die and an opponent's target die. Then choose an attack type.`;
            } else if (gamePhase === 'mindAttackInput') {
                playSound('click');
                if (clickedPlayerIndex === activePlayerIndex) {
                    const lastPart = currentFormulaParts[currentFormulaParts.length - 1];
                    // Allow operator after closing parenthesis or number, but not after another operator or opening parenthesis
                    if (lastPart && (ALPHA.includes(lastPart) || lastPart === ')') && !OPERATORS.includes(lastPart)) {
                        messageEl.textContent = "Please add an operator (+-*/) after a die or closing parenthesis.";
                        return;
                    }
                    if (lastPart === '(') { // If last part is an opening parenthesis, next must be a die or another opening parenthesis
                        messageEl.textContent = "Cannot place a die immediately after an opening parenthesis without an operator.";
                        return;
                    }
                    if (OPERATORS.includes(lastPart) && (clickedDie.label === '(' || clickedDie.label === ')')) {
                        messageEl.textContent = "Cannot place parenthesis immediately after an operator.";
                        return;
                    }

                    currentFormulaParts.push(clickedDie.label);
                    renderMindAttackDisplay();
                    const targetDie = players[selectedTargetDie.playerIndex].dice.find(d => d.id === selectedTargetDie.dieId);
                    messageEl.textContent = `Building formula to match ${targetDie.type.toUpperCase()} (${targetDie.value}). Click more dice or operators.`;
                } else {
                    messageEl.textContent = "You can only use your own dice to build the formula.";
                }
            }
            updateUI();
        }

        function executeStrengthAttack() {
            playSound('hit');
            if (!selectedAttackingDie || !selectedTargetDie) {
                messageEl.textContent = "Please select one of your dice to attack and one of your opponent's dice to target before attacking.";
                return;
            }
            if (selectedAttackingDie.playerIndex !== activePlayerIndex) {
                messageEl.textContent = "You can only use your own dice to attack.";
                return;
            }
            if (selectedTargetDie.playerIndex === activePlayerIndex) {
                messageEl.textContent = "You must target an opponent's die.";
                return;
            }

            const attacker = players[activePlayerIndex];
            const defenderIndex = selectedTargetDie.playerIndex;
            const defender = players[defenderIndex];

            const attackingDie = attacker.dice.find(d => d.id === selectedAttackingDie.dieId);
            const targetDie = defender.dice.find(d => d.id === selectedTargetDie.dieId);

            if (!attackingDie || !targetDie) {
                messageEl.textContent = "Error: Selected dice not found. Please re-select.";
                addGameLogMessage("Error: Selected dice for strength attack not found. Turn reset.", "error");
                switchTurn();
                return;
            }
            
            const originalAttackerValue = attackingDie.value;
            const originalTargetValue = targetDie.value;

            const animationPromises = [];

            const attackingDieEl = player0DicePoolEl.querySelector(`[data-die-id="${attackingDie.id}"]`) || player1DicePoolEl.querySelector(`[data-die-id="${attackingDie.id}"]`);
            if (attackingDieEl) {
                attackingDieEl.classList.add('die-attacking-animation');
                playSound('reroll');
                setTimeout(() => {
                    attackingDieEl.classList.remove('die-attacking-animation');
                    reRollSpecificDice(activePlayerIndex, [attackingDie]);
                    updateUI();
                }, 600);
            } else {
                 reRollSpecificDice(activePlayerIndex, [attackingDie]);
            }
            
            let attackMessage = `${attacker.name} performs Strength Attack AGAINST ${defender.name}'s ${targetDie.type} dice with value ${originalTargetValue} USING ${attacker.name}'s ${attackingDie.type} dice with value ${originalAttackerValue}.`;

            if (originalAttackerValue >= originalTargetValue) {
                const targetDieEl = player0DicePoolEl.querySelector(`[data-die-id="${targetDie.id}"]`) || player1DicePoolEl.querySelector(`[data-die-id="${targetDie.id}"]`);

                if (targetDieEl) {
                    const originalRect = targetDieEl.getBoundingClientRect();
                    const targetCapturedEl = (defenderIndex === 0 ? player0CapturedDiceEl : player1CapturedDiceEl);
                    const targetRect = targetCapturedEl.getBoundingClientRect();
                    
                    const clone = targetDieEl.cloneNode(true);
                    clone.classList.add('die-capture-animation');
                    clone.style.position = 'fixed';
                    clone.style.left = originalRect.left + 'px';
                    clone.style.top = originalRect.top + 'px';
                    clone.style.width = originalRect.width + 'px';
                    clone.style.height = originalRect.height + 'px';
                    
                    const dx = (targetRect.left + targetRect.width / 2) - (originalRect.left + originalRect.width / 2);
                    const dy = (targetRect.top + targetRect.height / 2) - (originalRect.top + originalRect.height / 2);

                    clone.style.setProperty('--dx', `${dx}px`);
                    clone.style.setProperty('--dy', `${dy}px`);

                    document.body.appendChild(clone);
                    targetDieEl.style.visibility = 'hidden';

                    playSound('ding');

                    animationPromises.push(new Promise(resolve => {
                        clone.addEventListener('animationend', () => {
                            clone.remove();
                            resolve();
                        }, { once: true });
                    }));
                }

                defender.dice = defender.dice.filter(d => d.id !== targetDie.id);
                attacker.captured.push(targetDie);
                attacker.score++;
                attackMessage += ` Captures ${defender.name}'s ${targetDie.type} dice.`;
                messageEl.textContent = `${attacker.name}'s ${attackingDie.type.toUpperCase()} (${originalAttackerValue}) captured ${defender.name}'s ${targetDie.type.toUpperCase()} (${originalTargetValue})!`;

            } else {
                attackMessage += ` Fails to capture ${defender.name}'s ${targetDie.type} dice.`;
                messageEl.textContent = `${attacker.name}'s ${attackingDie.type.toUpperCase()} (${originalAttackerValue}) failed to capture ${defender.name}'s ${targetDie.type.toUpperCase()} (${originalTargetValue}).`;
            }

            Promise.all(animationPromises).then(() => {
                attackMessage += ` ${attacker.name}'s ${attackingDie.type} dice reroll with value ${attackingDie.value}.`;
                addGameLogMessage(attackMessage, 'info');
                checkWinCondition();
                if (playing) {
                    switchTurn();
                }
            });
            if (animationPromises.length === 0) { // Fallback if no animation (e.g., targetDieEl not found)
                 attackMessage += ` ${attacker.name}'s ${attackingDie.type} dice reroll with value ${attackingDie.value}.`;
                 addGameLogMessage(attackMessage, 'info');
                 checkWinCondition();
                if (playing) {
                    switchTurn();
                }
            }
        }

        function startMindAttackInput() {
            playSound('zap');
            if (!selectedAttackingDie || !selectedTargetDie) {
                messageEl.textContent = "Please select one of your dice to attack and one of your opponent's dice to target before starting Mind Attack.";
                return;
            }
            if (players[activePlayerIndex].dice.length === 0) {
                messageEl.textContent = "You need dice to perform a Mind Attack!";
                return;
            }
            if (selectedTargetDie.playerIndex === activePlayerIndex) {
                messageEl.textContent = "You must target an opponent's die for a Mind Attack.";
                return;
            }

            gamePhase = 'mindAttackInput';
            currentFormulaParts = [];
            renderMindAttackDisplay();
            const defenderPlayerIndex = selectedTargetDie.playerIndex;
            const targetDie = players[defenderPlayerIndex].dice.find(d => d.id === selectedTargetDie.dieId);
            messageEl.textContent = `${players[activePlayerIndex].name}, click your dice (A, B, C...) and operator buttons to build a formula that equals ${players[defenderPlayerIndex].name}'s ${targetDie.type.toUpperCase()} (${targetDie.value}).`;
            addGameLogMessage(`${players[activePlayerIndex].name} initiates Mind Attack against ${players[defenderPlayerIndex].name}'s ${targetDie.type} (${targetDie.value}). Building formula.`, 'info');
            updateUI();
        }

        // NEW: Helper function to format mind attack formula for the log with colors
        function formatMindAttackFormulaForLog(formulaParts, attackerDice) {
            let formattedHtml = '';
            formulaParts.forEach(part => {
                if (ALPHA.includes(part)) { // It's a die label
                    const die = attackerDice.find(d => d.label === part);
                    if (die) {
                        const bgColor = DICE_COLORS_MAP[die.type] || '#fff';
                        formattedHtml += `<span class="formula-part" style="background-color: ${bgColor}; color: #34495e;">${die.value}</span>`;
                    } else {
                        formattedHtml += `<span class="formula-part">${part}</span>`; // Fallback if die not found
                    }
                } else { // It's an operator or parenthesis
                    formattedHtml += `<span class="formula-part">${part}</span>`;
                }
            });
            return formattedHtml.trim();
        }


        function executeMindAttack() {
            const formula = currentFormulaParts.join('');
            if (!formula) {
                messageEl.textContent = "Please build a formula first.";
                return;
            }

            const attacker = players[activePlayerIndex];
            const defenderIndex = selectedTargetDie.playerIndex;
            const defender = players[defenderIndex];
            const targetDie = defender.dice.find(d => d.id === selectedTargetDie.dieId);

            if (!targetDie) {
                messageEl.textContent = "Error: Target die not found. Please re-select.";
                addGameLogMessage("Error: Target die for mind attack not found. Turn reset.", "error");
                switchTurn();
                return;
            }

            const scope = {};
            attacker.dice.forEach(die => {
                scope[die.label] = die.value;
            });

            let result;
            let diceUsedInFormula = [];
            try {
                const node = math.parse(formula);
                result = node.evaluate(scope);

                node.filter(function (node) {
                    return node.type === 'SymbolNode' && ALPHA.includes(node.name);
                }).forEach(function (node) {
                    const dieLabel = node.name;
                    const correspondingDie = attacker.dice.find(d => d.label === dieLabel);
                    if (correspondingDie) {
                        if (!diceUsedInFormula.includes(correspondingDie)) {
                            diceUsedInFormula.push(correspondingDie);
                        }
                    }
                });

                if (diceUsedInFormula.length === 0) {
                    messageEl.textContent = "Your formula must use at least one of your dice. Click them to add them.";
                    return;
                }

            } catch (e) {
                messageEl.textContent = `Invalid formula: ${e.message}. Please check your expression.`;
                addGameLogMessage(`${attacker.name} submitted an invalid formula "${formula}": ${e.message}.`, 'error');
                return;
            }

            const animationPromises = [];
            diceUsedInFormula.forEach(die => {
                const dieEl = player0DicePoolEl.querySelector(`[data-die-id="${die.id}"]`) || player1DicePoolEl.querySelector(`[data-die-id="${die.id}"]`);
                if (dieEl) {
                    dieEl.classList.add('die-attacking-animation');
                    animationPromises.push(new Promise(resolve => {
                        setTimeout(() => {
                            dieEl.classList.remove('die-attacking-animation');
                            resolve();
                        }, 600);
                    }));
                }
            });
            playSound('reroll');

            const diceUsedInfo = diceUsedInFormula.map(d => `${d.type} dice value ${d.value}`).join(', ');
            // UPDATED: Use the new helper for the formula part of the log message
            const formattedFormulaHtml = formatMindAttackFormulaForLog(currentFormulaParts, attacker.dice);
            let attackMessage = `${attacker.name} performs Mind Attack AGAINST ${defender.name}'s ${targetDie.type} dice with value ${targetDie.value} USING ${attacker.name}'s ${diceUsedInfo} with the EQUATION ${formattedFormulaHtml}.`;

            Promise.all(animationPromises).then(() => {
                if (result === targetDie.value) {
                    defender.dice = defender.dice.filter(d => d.id !== targetDie.id);
                    attacker.captured.push(targetDie);
                    attacker.score++;
                    attackMessage += ` Captures ${defender.name}'s ${targetDie.type} dice.`;
                    messageEl.textContent = `${attacker.name}'s Mind Attack succeeded! Formula (${formula}) = ${result}. Captured ${defender.name}'s ${targetDie.type.toUpperCase()} (${targetDie.value})!`;
                    playSound('ding');
                } else {
                    attackMessage += ` Fails to capture ${defender.name}'s ${targetDie.type} dice. Result was ${result}, target was ${targetDie.value}.`;
                    messageEl.textContent = `${attacker.name}'s Mind Attack failed. Formula (${formula}) = ${result}, but target was ${targetDie.value}.`;
                }

                reRollSpecificDice(activePlayerIndex, diceUsedInFormula);
                const rerolledDiceInfo = diceUsedInFormula.map(d => `${d.type} dice reroll with value ${d.value}`).join(', ');
                if (rerolledDiceInfo) {
                    attackMessage += ` ${attacker.name}'s ${rerolledDiceInfo}.`;
                }
                // UPDATED: Pass true for isHtml
                addGameLogMessage(attackMessage, 'info', true);

                currentFormulaParts = [];
                renderMindAttackDisplay();
                gamePhase = 'playerTurn';

                checkWinCondition();
                if (playing) {
                    switchTurn();
                }
            });
        }

        function handlePass() {
            messageEl.textContent = `${players[activePlayerIndex].name} chose to pass.`;
            addGameLogMessage(`${players[activePlayerIndex].name} passes their turn.`, 'info');
            switchTurn();
        }

        function checkWinCondition() {
            const opponentPlayer = players[activePlayerIndex === 0 ? 1 : 0];
            if (opponentPlayer.dice.length === 0) {
                playing = false;
                gameOverOverlay.style.display = 'flex';
                const winnerName = players[activePlayerIndex].name;
                const loserName = opponentPlayer.name;
                gameOverMessageEl.textContent = `${winnerName} has captured all of ${loserName}'s dice and WINS THE GAME! Final Score: ${players[0].name}: ${players[0].score}, ${players[1].name}: ${players[1].score}.`;
                player0Panel.classList.remove('player--active');
                player1Panel.classList.remove('player--active');
                document.querySelector(`.player--${activePlayerIndex}`).classList.add('player--winner');
                playSound('win');
                addGameLogMessage(`${winnerName} WINS THE GAME! Final Score: ${players[0].name}: ${players[0].score}, ${players[1].name}: ${players[1].score}.`, 'win');
            }
        }

        // NEW: Layout preference functions
        function setLayoutPreference(position) {
            if (position === 'side') {
                mainContentWrapper.classList.add('log-side');
                logSideRadio.checked = true;
            } else {
                mainContentWrapper.classList.remove('log-side');
                logBottomRadio.checked = true;
            }
            localStorage.setItem('gameLogPosition', position);
        }

        function loadLayoutPreference() {
            const savedPosition = localStorage.getItem('gameLogPosition');
            if (savedPosition) {
                setLayoutPreference(savedPosition);
            } else {
                setLayoutPreference('bottom'); // Default if no preference saved
            }
        }

        // --- Event Listeners ---
        btnInitialRoll.addEventListener('click', determineFirstPlayer);
        btnStrengthAttack.addEventListener('click', executeStrengthAttack);
        btnMindAttack.addEventListener('click', startMindAttackInput);
        btnSubmitMindAttack.addEventListener('click', executeMindAttack);
        btnPass.addEventListener('click', handlePass);
        btnNewGame.addEventListener('click', initGame);
        btnPlayAgain.addEventListener('click', initGame);

        // Layout control event listeners
        logBottomRadio.addEventListener('change', () => setLayoutPreference('bottom'));
        logSideRadio.addEventListener('change', () => setLayoutPreference('side'));

        // Formula button listeners
        formulaButtons.forEach(button => {
            button.addEventListener('click', () => {
                if (gamePhase !== 'mindAttackInput') return;
                playSound('click');

                const value = button.dataset.value;
                const lastPart = currentFormulaParts[currentFormulaParts.length - 1];

                const isOperator = OPERATORS.includes(value);
                const lastIsOperator = OPERATORS.includes(lastPart);
                const lastIsLetter = ALPHA.includes(lastPart);
                const isParen = value === '(' || value === ')';

                if (currentFormulaParts.length === 0 && (isOperator || value === ')')) {
                    messageEl.textContent = "Formula cannot start with an operator or closing parenthesis.";
                    return;
                }
                if (isOperator && lastIsOperator) {
                     messageEl.textContent = "Cannot have consecutive operators.";
                     return;
                }
                if (lastIsLetter && ALPHA.includes(value)) {
                    messageEl.textContent = "Please add an operator between dice.";
                    return;
                }
                if (lastIsLetter && value === '(') {
                    messageEl.textContent = "Please add an operator before an opening parenthesis if preceded by a die.";
                    return;
                }
                if (lastPart === '(' && isOperator) {
                    messageEl.textContent = "Parenthesis cannot be immediately followed by an operator.";
                    return;
                }
                if (lastPart === '(' && value === ')') {
                    messageEl.textContent = "Cannot have empty parentheses.";
                    return;
                }
                
                currentFormulaParts.push(value);
                renderMindAttackDisplay();
                const targetDie = players[selectedTargetDie.playerIndex].dice.find(d => d.id === selectedTargetDie.dieId);
                messageEl.textContent = `Building formula to match ${targetDie.type.toUpperCase()} (${targetDie.value}).`;
                updateUI();
            });
        });
        
        btnFormulaClear.addEventListener('click', () => {
            if (gamePhase !== 'mindAttackInput') return;
            playSound('click');
            currentFormulaParts = [];
            renderMindAttackDisplay();
            messageEl.textContent = "Formula cleared. Start building your Mind Attack!";
            updateUI();
        });

        btnFormulaBackspace.addEventListener('click', () => {
            if (gamePhase !== 'mindAttackInput') return;
            playSound('click');
            if (currentFormulaParts.length > 0) {
                currentFormulaParts.pop();
                renderMindAttackDisplay();
                messageEl.textContent = "Last part removed.";
            } else {
                messageEl.textContent = "Formula is already empty.";
            }
            updateUI();
        });

        // Initial game setup
        initGame();
    </script>
</body>
</html>
